---
title: "coriandR: Panel of Normals"
subtitle: "Report"
date: "`r format(Sys.time(), '%d-%m-%Y')`"
output: pdf_document
params:
  pon_name: pon
---

# Generating PON: "`r params$pon_name`"

This report documents the creation of the Panel of Normals (PON) from sequencing runs of healthy individuals, which is later used in Copy Number Variantion analysis of single patient data on the same sequencing platform with `coriandR`.

This PON has to be generated only once, mapping at least three healthy sequencing libraries against the human genome using `bowtie2` and counted with `featureCounts` as specified in the accompanying documentation.

```{r, include=FALSE}
library(knitr)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(dev = "png", dpi = 150, dev.args = list(type = "cairo-png"))
```

## Raw Library Counts

Per default raw read counts per library are counted with `featureCounts` for the entire PON at once and stored in the `r params$pon_name`.`fc.tsv` file by the user.

Meta data about the samples (`sample` and `gender`) are specified in the `r params$pon_name`.`meta.tsv` file separated by comma (`,`) by the user.


```{r, data_definition, echo = FALSE}
# data definition
meta = read.table(paste0(params$pon_name, ".meta.csv"), stringsAsFactors = F, header = TRUE, sep = ",")
row.names(meta) = meta$sample

pon = read.table(paste0(params$pon_name, ".fc.tsv"), header = TRUE, stringsAsFactors = T)

if(nrow(meta) != ncol(pon)-6) {print("PON meta file and featureCounts of PON have different number of samples"); knitr::knit_exit()}

meta$pon.col = as.vector(as.numeric(sapply(meta$sample, function(x) grep(gsub("-", ".", x), names(pon)), simplify=T)))
if(any(is.na(meta$pon.col))) {print("PON meta file and featureCounts of PON have different names of samples"); knitr::knit_exit()}

names(pon)[meta$pon.col] = meta$sample

# gc-gehalt, erstellt mit bedtools
gc = read.table("genome/GRCh38.p13.genome.1M.nucl", stringsAsFactors = T)
pon$gc = gc[gc$V1 != 'chrM', 5]
```



### Sequencing depth of individual PON subjects
The following plot shows the sequencing depth of different PON libraries on a logarithmic scale per megabase.

Optimally all samples should be well above 100 and within the red dotted lines, representing $1/4$ and $4$ times the **median** sequencing depth.

Gender annotation of the samples should match distributions with one single cluster in females (F) or two distinctive clusters for autosomes and single copy X and Y chromosomes in males (M).

```{r, Reading in the PON and Patient counts, warning=F, fig.height=12, fig.width=7, echo = FALSE}
par(mar=c(3, 15, 1, 3), cex=0.7)
plot(c(t(pon[ ,meta$pon.col])), rep(1:nrow(meta), nrow(pon)),
     log = "x", xlab="Read depth", ylab="", yaxt = "n",
     pch = 20, col="#11111105")

abline(v=c(0.25, 4)*median(c(t(pon[ ,meta$pon.col])), na.rm=T), col='red', lty=2)

axis(4, 1:nrow(meta), las = 1, meta$gender)
axis(2, 1:nrow(meta), las = 1, meta$sample)
```


```{r, echo = FALSE}
#Just as an overview, on a non-log scale compared with the patient (blue line). There seem to be lots of PON bins with zero reads at the bottom.

#pat = read.table("patient.fc.tsv", header=TRUE, row.names=1, stringsAsFactors=T)
#pon$pat = pat[, 6]

#plot(rep(pon$bin, length(pon.cols)), c(t(pon[,pon.cols])),
#     ylim=c(0, qnorm(0.999, mean(as.matrix(pon[,pon.cols])), sd(as.matrix(pon[,pon.cols])))),
#     col=hsv(1:length(pon.cols)/length(pon.cols), alpha=0.1), pch=20, frame=F,
#     xaxt="n", xlab="Genome", ylab="#Reads")

#bereits hier werden die bins herausgefiltert, die ausserhalb der 99% um den mean herum liegen
#viele PON-bins mit den Nullen

#abline(v=c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555")
#axis(1, contigs, colnames(contigs))
#lines(pon$bin, pon$pat, col="blue")
```


### Cumulative PON
For later statistics the read counts of the PON are summed up over each bin.

Ideally, autosomes show up as a straight line of dots with minimal noise well above a read depth of at least 1000 reads per megabase.

Bins with counts outside of 99% of the normal distribution are marked in red. These should probably be masked in the end.

The values of gonosomes for men and women are represented: (from left to right) X male, X female, Y male, Y female. 

```{r, PON gender segregation, echo = FALSE}
# PoN gender segregation
gendering_pon <- function(pon, meta) {
  # gender_pon ist eine tabelle mit den spaltennamen im PON und mit den dazugehoerigen geschlechtern
  
  # zuerst das X-Chromosom in chrX_F und chrX_M aufteilen
  chrn = "chrX"
  # in eine separate tabelle werden alle zeilen von x-chr reingepackt
  pon.copy = pon[pon$Chr == chrn, ]
  # allen zeilen wird der suffix "_M" zugewiesen
  pon.copy$Chr = paste0(pon.copy$Chr, "_M")
  # nur die maenner sollten die werte fuer chrX_M behalten
  pon.copy[, meta$pon.col[meta$gender == "F"]] = NA
  pon.new = rbind(pon, pon.copy)
  
  pon.copy = pon[pon$Chr == chrn, ]
  pon.copy$Chr = paste0(pon.copy$Chr, "_F")
  pon.copy[, meta$pon.col[meta$gender == "M"]] = NA
  # pon.new ist jetzt um 2 "X-chr" groesser
  pon.new = rbind(pon.new, pon.copy)
  
  # dann Y-Chromosom
  chrn = "chrY"
  pon.copy = pon[pon$Chr == chrn, ]
  pon.copy$Chr = paste0(pon.copy$Chr, "_M")
  pon.copy[, meta$pon.col[meta$gender == "F"]] = NA
  pon.new = rbind(pon.new, pon.copy)
  
  pon.copy = pon[pon$Chr == chrn, ]
  pon.copy$Chr = paste0(pon.copy$Chr, "_F")
  pon.copy[, meta$pon.col[meta$gender == "M"]] = NA
  pon.new = rbind(pon.new, pon.copy)
  
  # zeilen mit den eigentlichen X- und Y-chromosomen loeschen
  pon.new = pon.new[!(pon.new$Chr == "chrX" | pon.new$Chr == "chrY"), ]
  pon = pon.new
}
#pon = gendering_pon(pon, meta)

ponXf = pon[pon$Chr == "chrX", ]
ponXf$Chr = "chrX_F"
ponXf[, meta$sample[meta$gender != "F"]] = NA

ponXm = pon[pon$Chr == "chrX", ]
ponXm$Chr = "chrX_M"
ponXm[, meta$sample[meta$gender != "M"]] = NA

ponYm = pon[pon$Chr == "chrY", ]
ponYm$Chr = "chrY_M"
ponYm[, meta$sample[meta$gender != "M"]] = NA


pon = rbind(pon[!pon$Chr %in% c("chrX", "chrY"), ], ponXf, ponXm, ponYm)


pon$bin = 1:nrow(pon)  # plain number all bins

contigs = data.frame(pos=tapply(pon$bin, pon$Chr, mean)) # middle coordinates of chromosomes for axis drawing
contigs$chr = gsub("chr", "", rownames(contigs))
contigs = contigs[order(as.numeric(contigs$chr)),]

```

```{r, Cumulative PON, echo = FALSE, fig.width = 12, fig.height = 5}
# One idea is to sum all PON reads of a bin up and compare/test the raw numbers with the Patient. This can be done by Binomial testing, or Testing the Odds-Ratio.
pon$sum = rowSums(pon[, meta$pon.col], na.rm=T)
pon$mean = rowMeans(pon[, meta$pon.col], na.rm=T)

plot(pon$bin, pon$mean, ylim = c(0, qnorm(0.999, mean(pon$mean), sd(pon$mean))),
     col = ifelse(pon$mean < qnorm(0.01, mean = mean(pon$mean), sd=sd(pon$mean)) | pon$mean > qnorm(0.99, mean = mean(pon$mean), sd = sd(pon$mean), lower.tail=T), "tomato3", "#11111111"),
     pch = 16, xaxt="n", xlab="", las = 1, ylab="avg. read depth", xaxs="i")
abline(v = c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555", cex = 0.5)
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))


#plot(pon$bin, pon$X62720_S6_L001.bam,
#     col = ifelse(pon$sum < qnorm(0.01, mean = mean(pon$sum), sd=sd(pon$sum)) | pon$sum > qnorm(0.99, #mean = mean(pon$sum), sd = sd(pon$sum), lower.tail=T), "#ff000055", "#55555522"),
#     pch=20, xaxt="n", xlab="Genome", ylab="Reads", frame=F)
#abline(v = c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555")
#axis(1, contigs, colnames(contigs))
```


## Normalizing PON by library size and per megabase
In order to compare the quality of multiple PONs, read depth is normalized by overall library size and then by the median for each megabase.

The genome plot should result in a tight distribution arount the ploidy of 2.

Gonosomes are shifted to match a ploidy of 2 in males to facilitate comparability.

```{r, Plotted over all chromosomes, echo = FALSE, fig.width = 12, fig.height = 5}

#Normalizing to a ploidity of 2, the PON looks much more straight forward aside from the samples with a second mode at 1 (gonosomes).

pon.norm = pon[, meta$pon.col]
#pon.norm = data.frame(t(t(pon.norm)/ apply(pon.norm, 2, median, na.rm=T)*2))
pon.norm = data.frame(t(t(pon.norm)/apply(pon.norm, 2, median, na.rm=T)))
#plot(unlist(pon[, meta$pon.col]), unlist(pon.norm))
pon.norm = data.frame(pon.norm/apply(pon.norm, 1, median, na.rm=T)*ifelse(pon$Chr %in% c("chrX_M", "chrY_M"), 1, 2))
#plot(rep(pon$bin, nrow(meta)), unlist(pon.norm), ylim=c(0,4))
#plot(c(t(pon.norm)), rep(1:length(pon.cols), nrow(pon)), xlab="Reads", ylab="Subjects", yaxt="n",
#     col = hsv(1:length(pon.cols)/ length(pon.cols), alpha=0.1), pch=20, xlim=c(0, 6))
#axis(4, 1:length(pon.cols), gender_pon$sex)

#pon$norm.pat = pon$pat/median(pon$pat, na.rm=T)*2

plot(rep(pon$bin, nrow(meta)), c(as.matrix(pon.norm)),      #col=rep(gray(1:length(pon.cols)/length(pon.cols), alpha=0.1), each=nrow(pon)),
     col ="#11111105", pch = 16, ylim=c(0, 4), yaxs="i",
     xaxt="n", xlab="Chromosomes", las = 1, ylab="Ploidy", xaxs="i")
abline(v=c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555")
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))
segments(c(0, 0, min(pon$bin[pon$Chr == "chrX_M"]), min(pon$bin[pon$Chr == "chrX_M"])), c(1.5, 2.5, 1.5, 0.5), c(max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin), max(pon$bin)), col="red", lty=2)
axis(4, 0:4, 0:4, las=2)
```

\newpage
## Masking bins with extreme GC-content and high variance
Some of the variance in bin counts might be due to uneven GC-content per bin.
GC-bias based on bedtools nucl statistics for same genome and same bins.

Plotting the GC-content vs normalized bin counts: We see hardly any influence of GC content on the data.
If GC content has little influence on variance, a large cigar-shaped point cloud appears at 2. 
If the GC content has a high influence on the reads, a diagonal or a banana-shaped curve can be seen. 

Quinlan A. R. (2014). BEDTools: The Swiss-Army Tool for Genome Feature Analysis. Current protocols in bioinformatics, 47, 11.12.1â€“11.12.34. doi: 10.1002/0471250953.bi1112s47.



```{r, plot GC-content, echo = FALSE, fig.width = 7, fig.height = 3}
pon$norm.var = c(apply(pon.norm, 1, var, na.rm=T))
pon$gc_blocked = pon$gc < qnorm(0.275, mean(pon$gc, na.rm=T), sd(pon$gc, na.rm=T))

par(mfrow=c(1,2))

plot(pon$gc, pon$norm.var, pch=20, ylim=c(0.0001, 0.2), xlim=c(0.25, 0.6),
     col=ifelse(pon$gc_blocked, "tomato3", "#11111111"),
     xlab="GC-content", ylab="Variance", las = 1, cex = 0.5)
points(rep(0.25, sum(pon$gc < 0.25)), pon$norm.var[pon$gc < 0.25], pch="<", col="tomato3")
points(pon$gc[!is.na(pon$norm.var) & pon$norm.var > 0.2], rep(0.2, sum(!is.na(pon$norm.var) & pon$norm.var > 0.2)), pch="^", col=ifelse(pon$gc_blocked, "tomato3", "#11111122")[!is.na(pon$norm.var) & pon$norm.var > 0.2])
gc.var = predict(loess(norm.var ~ gc, pon[pon$gc > 0.35 & pon$gc < 0.6,], span=0.5), 350:600/1000)
lines(350:600/1000, gc.var, col="blue")

plot(rep(pon$gc, ncol(pon.norm)), c(as.matrix(pon.norm)), pch=20, xlim=c(0.25, 0.6), ylim=c(0, 4),
     col = ifelse(pon$gc_blocked, "tomato3", "#11111111"),
     xlab="GC-content", ylab="Ploidy", las = 1, cex = 0.5)
abline(h=c(1.5, 2.5), col="red", lty=2)
```

Bins with extreme GC-content are marked in red.


# Masking high variance bins
The bins that were excluded from the statistical calculations are shown in color: due to very low GC-content (red), due to high variance (blue), or both (purple).

```{r, Masking high variance bins, echo = FALSE, fig.width = 12, fig.height = 5}
# One idea would be to clear single bins of single PON subjects where depth is below or above 99% of other subjects for that bin.
# For small PONs this is to coarse and probably not warrented overall...

pon.norm.clean = data.frame(t(apply(pon.norm, 1, function(x) {x[x < qnorm(0.01, mean(x), sd(x)) | x > qnorm(0.99, mean(x), sd(x))] = NA; x})))
pon$norm.clean.var = c(apply(pon.norm.clean, 1, var, na.rm=T))
pon$var_blocked = pon$sum < 1 | pon$norm.clean.var > qnorm(0.9, mean(pon$norm.clean.var[!pon$gc_blocked], na.rm=T), sd(pon$norm.clean.var[!pon$gc_blocked], na.rm=T))

plot(rep(pon$bin, nrow(meta)), c(as.matrix(pon.norm.clean)),
     col=ifelse(pon$gc_blocked, ifelse(pon$var_blocked, "#aa33aa55", "#aa331155"), ifelse(pon$var_blocked, "#1133aa55", "#11111105")),
     ylim=c(0, 4), yaxs="i", pch=16,
     xaxt="n", xlab="Chromosomes", las = 1, ylab="Ploidy", xaxs="i")
abline(v = c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555", cex = 0.5)
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))
segments(c(0, 0, min(pon$bin[pon$Chr == "chrX_M"]), min(pon$bin[pon$Chr == "chrX_M"])), c(1.5, 2.5, 1.5, 0.5), c(max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin), max(pon$bin)), col="red", lty=2)
axis(4, 0:4, 0:4, las=2)
```

\newpage
# Variance and normalized abundance after filtering

```{r, gc content after correction, echo = FALSE, fig.width = 7, fig.height = 3}
pon$norm.clean.var[pon$gc_blocked | pon$var_blocked] = NA
pon.norm.clean[pon$gc_blocked | pon$var_blocked, ] = rep(NA, ncol(pon.norm))

pon$norm.pat[pon$var_blocked | pon$gc_blocked] = NA

par(mfrow=c(1,2))
plot(pon$gc, pon$norm.clean.var, col="#11111105", pch=20, ylim=c(0.00001, 0.2), xlim=c(0.25, 0.6), xlab="GC-content", ylab="Variance", las = 1, cex = 0.5)
gc.var.clean = predict(loess(norm.clean.var ~ gc, pon[pon$gc > 0.33 & pon$gc < 0.6,], span=0.5), 330:550/1000)
lines(330:550/1000, gc.var.clean, col="blue")

plot(rep(pon$gc, ncol(pon.norm)), c(as.matrix(pon.norm.clean)), pch=20, xlim=c(0.25, 0.6), ylim=c(0, 4),
     col="#11111105", xlab="GC-content",
     ylab="Ploidy", las = 1, cex = 0.5)
abline(h=c(1.5, 2.5), col="red", lty=2)
```



# Filtered PON chromosomal overview
The final filtered PON should exhibit a tight distribution around 2 for all chromosomes and should not exceed the red boundaries, in order to reliably call monoallelic deletions or insertions.

```{r, corrected PON overview, echo = FALSE, fig.width = 12, fig.height = 5}
plot(rep(pon$bin, nrow(meta)), c(as.matrix(pon.norm.clean)),
     col ="#11111105", pch = 16, ylim=c(0, 4), yaxs="i",
     xaxt="n", xlab="Chromosomes", las = 1, ylab="Ploidy", xaxs="i")
abline(v = c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555", cex = 0.5)
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))
segments(c(0, 0, min(pon$bin[pon$Chr == "chrX_M"]), min(pon$bin[pon$Chr == "chrX_M"])), c(1.5, 2.5, 1.5, 0.5), c(max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin), max(pon$bin)), col="red", lty=2)
axis(4, 0:4, 0:4, las=2)
```





```{r, Binomial testing, echo = FALSE}
#rate = with(pon[!(pon$gc_blocked | pon$var_blocked), ], sum(pat)/(sum(sum)+sum(pat)))
#pon$binom = apply(pon[, c("pat", "sum")], 1, function(x) ifelse(x[2] > 0, binom.test(x[1], x[2]+x[1], rate)$p.value, 1))
#pon$binom.adjust = p.adjust(pon$binom, method="hochberg")
```

```{r, Gaussian testing of normalized counts, echo = FALSE}
#sd = sd(unlist(pon.norm.clean)/2, na.rm=T)
#pon$pat.z = (pon$norm.pat-2)/2 / sd
#pon$ttest = ifelse(pon$gc_blocked | pon$var_blocked, 1, 2*pnorm(q=-abs(pon$pat.z)))

#plot(seq(from=-10, to=10, by=0.1), dnorm(seq(from=-10, to=10, by=0.1)), type='l', col="gray",
#     main="Patien z-values compared to estimated PON distribution", ylab="Density", xlab="z-value")
#lines(density(pon$pat.z, na.rm=T), col="red")
#legend("topright", legend=c("Estimated PON", "Patient"), col=c("gray", "red"), lty=1)
```




```{r, PON normalisation old function, echo = FALSE}
# The normalisation of Panel of normals by median
#panel_of_normals_normalization <- function(pon) {
#  pon_norm <- pon[ , 1:5]
#  for (c in 6:ncol(pon)) {
#    pon_norm[ , c] <- pon[ , c] / median(pon[ , c]) *2
#  }
#  return(pon_norm)
#}


#means_panel_of_normals <- function(pon) {
#  
#  pon_means <- apply(pon[ , 6:(ncol(pon))], 1, function(x) mean(x, na.rm = TRUE))
#  pon_sd <- apply(pon[ , 6:(ncol(pon))], 1, function(x) sd(x, na.rm = TRUE))
#  
#  return (cbind(pon, 'mean'=pon_means, 'sd'=pon_sd))
#}
```

```{r, write the PON table, echo = FALSE}
#pon = panel_of_normals_normalization(pon)

#pon = means_panel_of_normals(pon)
pon$norm = rowMeans(pon.norm)
pon$norm_sd = apply(pon.norm, 1, sd, na.rm=T)
write.table(pon, file = paste0(params$pon_name, ".pon.tsv"), sep = "\t", row.names = TRUE, col.names = NA)
```

