---
title: "coriandR: Panel of Normals"
subtitle: "Report"
date: "`r format(Sys.time(), '%d-%m-%Y')`"
output: pdf_document
params:
  pon_name: pon
---

# Generating PON: "`r params$pon_name`"

This report documents the creation of the Panel of Normals (PON) from sequencing runs of healthy individuals, which is later used in Copy Number Variantion analysis of single patient data on the same sequencing platform with `coriandR`.

This PON has to be generated only once, mapping at least three healthy sequencing libraries against the human genome using `bowtie2` and counted with `featureCounts` as specified in the accompanying documentation.

```{r, include=FALSE}
library(knitr)

knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(dev = "png", dpi = 150, dev.args = list(type = "cairo-png"))
```


## Raw Library Counts

Per default raw read counts per library are counted with `featureCounts` for the entire PON at once and stored in the `r params$pon_name`.`fc.tsv` file by the user.

Meta data about the samples (`sample` and `gender`) are specified in the `r params$pon_name`.`meta.tsv` file separated by comma (`,`) by the user.

```{r, data_definition, echo = FALSE}
# meta information with sample mapping files and genders
meta = read.table(paste0(params$pon_name, ".meta.csv"), stringsAsFactors = F, header = TRUE, sep = ",")
row.names(meta) = meta$sample

# raw PON counts
pon = read.table(paste0(params$pon_name, ".fc.tsv"), header = TRUE, stringsAsFactors = T)
if(nrow(meta) != ncol(pon)-6) {
  print("PON meta file and featureCounts of PON have different number of samples")
  knitr::knit_exit()
}

meta$pon.col = as.vector(as.numeric(sapply(meta$sample, function(x) grep(gsub("-", ".", x), names(pon)), simplify=T)))
if(any(is.na(meta$pon.col))) {
  print("PON meta file and featureCounts of PON have different names of samples")
  knitr::knit_exit()
}

# rename PON colums of samples
names(pon)[meta$pon.col] = meta$sample

# GC-content calculated by bedtools
gc = read.table("GRCh38.p13.genome.1M.nucl", stringsAsFactors = T)
pon$gc = gc[gc$V1 != 'chrM', 5]
```


### Sequencing depth of individual PON subjects
The following plot shows the sequencing depth of different PON libraries on a logarithmic scale per megabase.

Optimally all samples should be well above 100 and within the red dotted lines, representing $1/4$ and $4$ times the **median** sequencing depth.

Gender annotation of the samples should match distributions with one single cluster in females (F) or two distinctive clusters for autosomes and single copy X and Y chromosomes in males (M).

```{r, Reading in the PON and Patient counts, warning=F, fig.height=12, fig.width=7, echo = FALSE}
par(mar=c(3, 15, 1, 3), cex=0.7)
plot(c(t(pon[ ,meta$pon.col])), rep(1:nrow(meta), nrow(pon)),
     log = "x", xlab="Read depth", ylab="", yaxt = "n",
     pch = 20, col="#11111105")
abline(v=c(0.25, 4)*median(c(t(pon[ ,meta$pon.col])), na.rm=T), col='red', lty=2)
axis(4, 1:nrow(meta), las = 1, meta$gender)
axis(2, 1:nrow(meta), las = 1, meta$sample)
```

  
### Cumulative PON
For later statistics the read counts of the PON are summed up over each bin.

Ideally, autosomes show up as a straight line of dots with minimal noise well above a read depth of at least 1000 reads per megabase.

Bins with counts outside of 99% of the normal distribution are marked in red. These should probably be masked in the end.

The values of gonosomes for men and women are represented: (from left to right) X male, X female, Y male, Y female. 

```{r, PON gender segregation, echo = FALSE}
pon$ploidy = 2
ponXf = pon[pon$Chr == "chrX", ]
ponXf$Chr = "chrX_F"
ponXf$gender = "F"
ponXf[, meta$sample[meta$gender != "F"]] = NA

ponXm = pon[pon$Chr == "chrX", ]
ponXm$Chr = "chrX_M"
ponXm$gender = "M"
ponXm$ploidy = 1
ponXm[, meta$sample[meta$gender != "M"]] = NA

ponYm = pon[pon$Chr == "chrY", ]
ponYm$Chr = "chrY_M"
ponYm$gender = "M"
ponYm$ploidy = 1
ponYm[, meta$sample[meta$gender != "M"]] = NA

pon$gender = "neutral"

pon = rbind(pon[!pon$Chr %in% c("chrX", "chrY"), ], ponXf, ponXm, ponYm)

pon$gender = factor(pon$gender)

pon$bin = 1:nrow(pon)  # plain number all bins

# chromosome names and middle coordinates of each for axis drawing
contigs = data.frame(pos=tapply(pon$bin, pon$Chr, mean))
contigs$chr = gsub("chr", "", rownames(contigs))
contigs = contigs[order(as.numeric(contigs$chr)),]
```


```{r, Cumulative PON, echo = FALSE, fig.width = 12, fig.height = 5}
# One idea is to sum all PON reads of a bin up and compare/test the raw numbers with the Patient. This can be done by Binomial testing, or Testing the Odds-Ratio.
pon$sum = rowSums(pon[, meta$pon.col], na.rm=T)
pon$mean = rowMeans(pon[, meta$pon.col], na.rm=T)
plot(pon$bin, pon$mean, ylim = c(0, qnorm(0.999, mean(pon$mean), sd(pon$mean))),
     col = ifelse(pon$mean < qnorm(0.01, mean = mean(pon$mean), sd=sd(pon$mean)) | pon$mean > qnorm(0.99, mean = mean(pon$mean), sd = sd(pon$mean), lower.tail=T), "tomato3", "#11111111"),
     pch = 16, xaxt="n", xlab="", las = 1, ylab="avg. read depth", xaxs="i")
abline(v = c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555", cex = 0.5)
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))
```


## Normalizing PON by library size and per megabase
In order to compare the quality of multiple PONs, read depth is normalized by overall library size and then by the median for each megabase.

The genome plot should result in a tight distribution arount the ploidy of 2.

Gonosomes are shifted to match a ploidy of 2 in males to facilitate comparability.

```{r, Plotted over all chromosomes, echo = FALSE, fig.width = 12, fig.height = 5}
# Normalizing to a ploidity of 2, the PON looks much more straight forward aside from the samples with a second mode at 1 (gonosomes).

pon.norm = pon[, meta$pon.col]
pon.norm = data.frame(t(t(pon.norm)/apply(pon.norm, 2, median, na.rm=T)))
pon$norm.median = apply(pon.norm, 1, median, na.rm=T)
pon$norm.clean.sd = apply(pon.norm, 1, sd, na.rm=T)
pon.nnorm = data.frame(pon.norm/apply(pon.norm, 1, median, na.rm=T))
plot(rep(pon$bin, nrow(meta)), c(as.matrix(pon.nnorm)*pon$ploidy),      #col=rep(gray(1:length(pon.cols)/length(pon.cols), alpha=0.1), each=nrow(pon)),
     col ="#11111105", pch = 16, ylim=c(0, 4), yaxs="i",
     xaxt="n", xlab="Chromosomes", las = 1, ylab="Ploidy", xaxs="i")
abline(v=c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555")
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))
segments(c(0, 0, min(pon$bin[pon$Chr == "chrX_M"]), min(pon$bin[pon$Chr == "chrX_M"])), c(1.5, 2.5, 1.5, 0.5), c(max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin), max(pon$bin)), col="red", lty=2)
axis(4, 0:4, 0:4, las=2)
```


\newpage
## Masking bins with extreme GC-content and high variance
Some of the variance in bin counts might be due to uneven GC-content per bin.
GC-bias based on bedtools nucl statistics for same genome and same bins.

Plotting the GC-content vs normalized bin counts: We see hardly any influence of GC content on the data.
If GC content has little influence on variance, a large cigar-shaped point cloud appears at 2. 
If the GC content has a high influence on the reads, a diagonal or a banana-shaped curve can be seen. 

Quinlan A. R. (2014). BEDTools: The Swiss-Army Tool for Genome Feature Analysis. Current protocols in bioinformatics, 47, 11.12.1â€“11.12.34. doi: 10.1002/0471250953.bi1112s47.


```{r, plot GC-content, echo = FALSE, fig.width = 7, fig.height = 3}
pon$norm.var = c(apply(pon.norm, 1, var, na.rm=T))
pon$gc_blocked = pon$gc < qnorm(0.275, mean(pon$gc, na.rm=T), sd(pon$gc, na.rm=T))
par(mfrow=c(1,2))
plot(pon$gc, pon$norm.var, pch=20, ylim=c(0.0001, 0.2), xlim=c(0.25, 0.6),
     col=ifelse(pon$gc_blocked, "tomato3", "#11111111"),
     xlab="GC-content", ylab="Variance", las = 1, cex = 0.5)
points(rep(0.25, sum(pon$gc < 0.25)), pon$norm.var[pon$gc < 0.25], pch="<", col="tomato3")
points(pon$gc[!is.na(pon$norm.var) & pon$norm.var > 0.2], rep(0.2, sum(!is.na(pon$norm.var) & pon$norm.var > 0.2)), pch="^", col=ifelse(pon$gc_blocked, "tomato3", "#11111122")[!is.na(pon$norm.var) & pon$norm.var > 0.2])
gc.var = predict(loess(norm.var ~ gc, pon[pon$gc > 0.35 & pon$gc < 0.6,], span=0.5), 350:600/1000)
lines(350:600/1000, gc.var, col="blue")
plot(rep(pon$gc, ncol(pon.norm)), c(as.matrix(pon.norm)*pon$ploidy), pch=20, xlim=c(0.25, 0.6), ylim=c(0, 4),
     col = ifelse(pon$gc_blocked, "tomato3", "#11111111"),
     xlab="GC-content", ylab="Ploidy", las = 1, cex = 0.5)
abline(h=c(1.5, 2.5), col="red", lty=2)
```

Bins with extreme GC-content are marked in red.


# Masking high variance bins
The bins that were excluded from the statistical calculations are shown in color: due to very low GC-content (red), due to high variance (blue), or both (purple).

```{r, Masking high variance bins, echo = FALSE, fig.width = 12, fig.height = 5}
# One idea would be to clear single bins of single PON subjects where depth is below or above 99% of other subjects for that bin.
# For small PONs this is to coarse and probably not warrented overall...

norm.sd = mean(apply(pon.norm, 1, sd, na.rm=T))
pon.norm.clean = data.frame(t(apply(pon.norm, 1, function(x) {x[x < qnorm(0.01, mean(x), norm.sd) | x > qnorm(0.99, mean(x), norm.sd)] = NA; x})))
pon$norm.clean.mean = rowMeans(pon.norm.clean, na.rm=T)
pon$norm.clean.var = c(apply(pon.norm.clean, 1, var, na.rm=T))
pon$norm.clean.sd = c(apply(pon.norm.clean, 1, sd, na.rm=T))
pon$var_blocked = pon$sum < 1 | (!is.na(pon$norm.clean.var) & pon$norm.clean.var > qnorm(0.9, mean(pon$norm.clean.var[!pon$gc_blocked], na.rm=T), sd(pon$norm.clean.var[!pon$gc_blocked], na.rm=T)))
pon$blocked = pon$var_blocked | pon$gc_blocked

plot(rep(pon$bin, nrow(meta)), c(as.matrix(pon.norm.clean)*pon$ploidy),
     col=ifelse(pon$gc_blocked, ifelse(pon$var_blocked, "#aa33aa55", "#aa331155"), ifelse(pon$var_blocked, "#1133aa55", "#11111105")),
     ylim=c(0, 4), yaxs="i", pch=16,
     xaxt="n", xlab="Chromosomes", las = 1, ylab="Ploidy", xaxs="i")
abline(v = c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555", cex = 0.5)
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))
segments(c(0, 0, min(pon$bin[pon$Chr == "chrX_M"]), min(pon$bin[pon$Chr == "chrX_M"])), c(1.5, 2.5, 1.5, 0.5), c(max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin), max(pon$bin)), col="red", lty=2)
axis(4, 0:4, 0:4, las=2)
```


\newpage
# Variance and normalized abundance after filtering

```{r, gc content after correction, echo = FALSE, fig.width = 7, fig.height = 3}
par(mfrow=c(1,2))
with(pon[!pon$blocked, ], {
plot(gc, norm.clean.var, col="#11111105", pch=20, ylim=c(0.00001, 0.2), xlim=c(0.25, 0.6), xlab="GC-content", ylab="Variance", las = 1, cex = 0.5)
gc.var.clean = predict(loess(norm.clean.var ~ gc, pon[pon$gc > 0.33 & pon$gc < 0.6,], span=0.5), 330:550/1000)
lines(330:550/1000, gc.var.clean, col="blue")
plot(rep(gc, ncol(pon.norm)), c(as.matrix(pon.norm.clean[!pon$blocked, ])*pon$ploidy), pch=20, xlim=c(0.25, 0.6), ylim=c(0, 4),
     col="#11111105", xlab="GC-content",
     ylab="Ploidy", las = 1, cex = 0.5)
abline(h=c(1.5, 2.5), col="red", lty=2)
})
```


# Filtered PON chromosomal overview
The final filtered PON should exhibit a tight distribution around 2 for all chromosomes and should not exceed the red boundaries, in order to reliably call monoallelic deletions or insertions.

```{r, corrected PON overview, echo = FALSE, fig.width = 12, fig.height = 5}
plot(rep(pon$bin[!pon$blocked], nrow(meta)), c(as.matrix(pon.norm.clean[!pon$blocked, ])*pon$ploidy[!pon$blocked]),
     col ="#11111105", pch = 16, ylim=c(0, 4), yaxs="i",
     xaxt="n", xlab="Chromosomes", las = 1, ylab="Ploidy", xaxs="i")
abline(v = c(pon$bin[pon$Start == 1], nrow(pon)), col="#55555555", cex = 0.5)
with(contigs[(1:(nrow(contigs)/2))*2, ], axis(side=1, labels=chr, at=pos, line=1, cex=0.5, tick=F))
with(contigs[(1:(nrow(contigs)/2))*2-1, ], axis(side=1, labels=chr, at=pos, line=0, cex=0.5, tick=F))
segments(c(0, 0, min(pon$bin[pon$Chr == "chrX_M"]), min(pon$bin[pon$Chr == "chrX_M"])), c(1.5, 2.5, 1.5, 0.5), c(max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin[pon$Chr == "chrX_F"]), max(pon$bin), max(pon$bin)), col="red", lty=2)
axis(4, 0:4, 0:4, las=2)
```


```{r, save the PON table, echo = FALSE}
write.table(pon, file = paste0(params$pon_name, ".pon.tsv"), sep = "\t", row.names = TRUE, col.names = NA)
```
```